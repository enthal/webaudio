<html>

<head>
  <title>Web Audio demo 2 - Step sequencer</title>
  <style>

    body { font-size: 300%; text-align: center; }

    #top-controls {
      padding: 0.2em;
      background-color: #f7f7f7;
    }
    #top-controls > * {
      display: inline-block;
      background-color: #DDD;
      padding: 0 0.2em;
      border-radius: 10px;
      font-family: monospace;
    }

    #play-stop-button:before { content: "▶︎"; }
    .playing #play-stop-button:before { content: "||"; }
    #restart-button:before { content: "⎌"; }

    #beat-grid button {
      background-color: #444;
      width:  4em;
      height: 4em;
    }
    #beat-grid button.on {
      background-color: #DD0;
    }
    #beat-grid button.current {
      background-color: #888;
    }
    #beat-grid button.current.on {
      background-color: #FF3;
    }
  </style>
</head>

<body id=app-root>

  <div id=top-controls>
    <div id=play-stop-button></div>
    <div id=restart-button></div>
    <div id=beat-value></div>
    <div id=time-value></div>
  </div>

  <div id=beat-grid></div>
</div>
</body>

<script>

  const RUN = () => {
    makeDomBeatGrid();
  }

  ////////////

  const stepCount = 8;
  const drumNotes = [ 69-12, 69-7, 69 ];  // 69 == MIDI A4
  const grid = [];
  const makeDomBeatGrid = () => {
    drumNotes.forEach( (drumNote, drumI) => {
      const drum = [];
      grid.push(drum);

      const drumRow = document.createElement('div');
      document.querySelector('#beat-grid').appendChild( drumRow );
      for (let stepI = 0; stepI < stepCount; stepI++) {
        drum.push(false);
        const button = document.createElement('button');
        button.addEventListener('click', () => {
          drum[stepI] = !drum[stepI];
          button.classList.toggle('on', drum[stepI]);
          resetLookaheadSchedule();
        });
        drumRow.appendChild(button);
      }


    })

    // thinking out loud; an imagined evolution on https://gist.github.com/jonathantneal/7935589
    H.e(H.s('#beat-grid'), drumNotes.map((drumNote, drumI) => {
      const drum = [];
      grid.push(drum);
      return H.n(stepCount, stepI => {
        drum.push(false);
        H.e('button', button => {click: () => {
          drum[stepI] = !drum[stepI];
          H.cl(button, 'on', drum[stepI]);
          resetLookaheadSchedule();
        }})
      })
    }))
  }

  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const freqForMidiNoteNumber = n => Math.pow(2, (n-69)/12) * 440

  const master = audioCtx.createGain();
  master.gain.value = 0.2;
  master.connect(audioCtx.destination);

  const scheduledNodeSet = new Set;

  const scheduleOscillator = (midiNote, startTime) => {
    const duration = 1.0;
    const oscillator = audioCtx.createOscillator();
    oscillator.$startTime = startTime;  // dirty?  for later cancellation
    // oscillator.type = 'triangle';
    oscillator.frequency.value = freqForMidiNoteNumber(midiNote);
    oscillator.start(startTime + 0.0);
    oscillator.stop (startTime + duration*2);

    const envelope = audioCtx.createGain();
    envelope.gain.setValueAtTime               (0.0, startTime + 0);                 // initial
    envelope.gain.linearRampToValueAtTime    (0.001, startTime + duration * 0.00000001);  // exponentialRampToValueAtTime clicks if started from 0
    envelope.gain.exponentialRampToValueAtTime (1.0, startTime + duration * 0.015);  // Attack
    envelope.gain.exponentialRampToValueAtTime (0.3, startTime + duration * 0.4);    // Decay
    envelope.gain.setValueAtTime               (0.3, startTime + duration * 0.8);    // Sustain
    envelope.gain.linearRampToValueAtTime      (0.0, startTime + duration * 2.0);    // Release

    oscillator.connect(envelope);
    envelope.connect(master);

    scheduledNodeSet.add(oscillator);
    oscillator.onended = () => {  // on stop/end by _any_ means
      scheduledNodeSet.delete(oscillator);
      // console.log("end", audioCtx.currentTime);
    }
    // console.log("schedule start", startTime, midiNote, audioCtx.currentTime, );
  }

  let playing = false
  const bps = 160/60;
  const lookaheadDuration = 1
  let startTime = audioCtx.currentTime
  const beatValueDomNode = document.querySelector('#beat-value');
  const timeValueDomNode = document.querySelector('#time-value');

  // C.f., https://www.html5rocks.com/en/tutorials/audio/scheduling/
  let lookaheadBeatI = 0;  // lookahead beat
  let lastCurrentBeatI = -1;
  const incrementLookaheadSchedule = () => {
    const playTime = audioCtx.currentTime - startTime;
    const currentBeatI = Math.floor(playTime * bps);
    if (lastCurrentBeatI !== currentBeatI) {
      if (!(currentBeatI%8))  console.log("-- LOOP");
      lastCurrentBeatI = currentBeatI;
      // timeValueDomNode.innerText = playTime;
      beatValueDomNode.innerText = currentBeatI;
      timeValueDomNode.innerText = (currentBeatI / bps).toFixed(2);

      // TODO: instead push beat events to consumers for update
      document.querySelectorAll('#beat-grid button.current')
        .forEach(x=>x.classList.remove('current'));
      document.querySelectorAll(`#beat-grid button:nth-child(${ 1 + currentBeatI % stepCount })`)
        .forEach(x=>x.classList.add('current'));

      // console.log("currentBeatI",currentBeatI);
    }

    for (
        let beatTime;
        (beatTime = 1/bps * lookaheadBeatI)  <  playTime + lookaheadDuration;
        lookaheadBeatI++
    ) {
      const scheduleTime = startTime + beatTime;
      if (scheduleTime < audioCtx.currentTime)  continue;  // skip this beat if already begun
      const stepI = lookaheadBeatI % stepCount;
      let scheduledCount = 0;
      drumNotes.forEach( (drumNote, drumI) => {
        if (grid[drumI][stepI]) {
          scheduleOscillator(drumNote, scheduleTime);
          scheduledCount++;
        }
      });
      if (scheduledCount) {
        console.log("scheduled", scheduledCount, stepI, lookaheadBeatI%4,
          lookaheadBeatI, beatTime.toFixed(4), (playTime + lookaheadDuration).toFixed(4))
      }
      // console.log("schedule beat", stepI, lookaheadBeatI%4, lookaheadBeatI, beatTime, playTime, audioCtx.currentTime)
    }

    playing ? audioCtx.resume() : audioCtx.suspend();   // TODO: seems OK to call this every time, but...
  }

  resetLookaheadSchedule = () => {
    // Stop only nodes that haven't started playing.
    console.log("** resetLookaheadSchedule", audioCtx.currentTime)
    scheduledNodeSet.forEach( x => {
      let stopped;
      if (x.$startTime >= audioCtx.currentTime) {   // == if reset to start time while paused
        stopped = true;
        x.stop();  // resulting onended callback will remove from scheduledNodeSet
      }
      console.log(x.$startTime, stopped?"stop":"spare", +(x.$startTime - audioCtx.currentTime).toFixed(4), x);
    } );

    lookaheadBeatI = lastCurrentBeatI;  // next incrementLookaheadSchedule will rebuild
  }

  const scheduleForever = () => {
    incrementLookaheadSchedule();
    window.requestAnimationFrame(scheduleForever)
  }
  window.requestAnimationFrame(scheduleForever)  // https://www.html5rocks.com/en/tutorials/audio/scheduling/

  audioCtx.suspend();
  document.querySelector('#play-stop-button').addEventListener('click', () => {
    playing = !playing
    document.querySelector('#app-root').classList.toggle('playing',playing)
    console.log("playing",playing);
  })
  document.querySelector('#restart-button').addEventListener('click', () => {
    console.log("restart");
    scheduledNodeSet.forEach( x => {
      console.log("stop", x);
      x.stop();  // stop even already-playing notes
    } );
    startTime = audioCtx.currentTime;
    lookaheadBeatI = 0;
    lastCurrentBeatI = -1;
    audioCtx.suspend();  // but still perhaps playing==true: if so, will resume in incrementLookaheadSchedule; ensures we schedule first beat!
  })


  RUN();
</script>

</html>
