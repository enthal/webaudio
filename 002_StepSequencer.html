<html>

<head>
  <title>Web Audio demo 2 - Step sequencer</title>
  <style>

    body {
      text-align: center;
      font-family: sans-serif;
    }

    #top-controls {
      padding: 0.2em;
      background-color: #f7f7f7;
    }
    #top-controls *:not(.row) {
      background-color: #DDD;
      padding: 0 0.2em;
      border-radius: 10px;
    }
    #top-controls .button {
      font-size: 300%;
    }
    #top-controls .value {
      font-size: 200%;
      font-family: monospace;
    }
    #top-controls .control {
      padding: 0.4em;
    }
    #top-controls .control > * {
      display: block;
      text-align: left;
    }
    #top-controls .control label {
      padding-right: 1em
    }

    #play-pause-button:before { content: "▶︎"; }
    .playing #play-pause-button:before { content: "||"; }
    #restart-button:before { content: "⎌"; }

    #beat-grid button {
      background-color: #444;
      width:  4em;
      height: 4em;
    }
    #beat-grid button.on {
      background-color: #DD0;
    }
    #beat-grid button.current {
      background-color: #888;
    }
    #beat-grid button.current.on {
      background-color: #FF3;
    }

    .row > * {
      display: inline-block;
      margin-bottom: 0.2em;
    }
  </style>
</head>

<body id=app-root>

  <div id=top-controls>

    <div class=row>
      <div id=play-pause-button class=button></div>
      <div id=restart-button   class=button></div>
      <div id=beat-value class=value></div>
      <div id=time-value class=value></div>
    </div>

    <div class=row>

      <div id="gain-control" class=control>
        <div>
          <label for="gain-input">Gain</label>
          <span class=value>123</span>
        </div>
        <input name="gain-input" type="range" min="0" max="1" value=0.2 step="0.05" />
      </div>

      <div id="bpm-control" class=control>
        <div>
          <label for="bpm-input">BPM</label>
          <span class=value>123</span>
        </div>
        <input name="bpm-input" type="range" min="1" max="240" value="120" step="1" />
      </div>

    </div>
  </div>

  <div id=beat-grid></div>
</div>
</body>

<script>

  const RUN = () => {
    const scheduler = makeScheduler();
    const master = makeMaster();
    attachBeatGrid(scheduler, master);
  }


  const makeScheduler = () => {
    const scheduledNodeSet = new Set;
    const handlers = new Set;
    const tellHandlers = (type, ...args) =>
      [...handlers].map( handler => handler[type] && handler[type](...args) );

    let playing = false;
    let bps = 160/60;
    const lookaheadDuration = 1;
    const beatValueDomNode = document.querySelector('#beat-value');  // TODO: MOVE!!
    const timeValueDomNode = document.querySelector('#time-value');  // TODO: MOVE!!

    // C.f., https://www.html5rocks.com/en/tutorials/audio/scheduling/
    /*let*/ lastScheduleCallTime = audioCtx.currentTime;
    const incrementLookaheadSchedule = () => {
      const now = audioCtx.currentTime;
      const playTime = now - startTime;
      const beatI = Math.floor(beatReal);

      if (lastBeatI !== beatI) {
        lastBeatI = beatI;

        // TODO: MOVE!!
        beatValueDomNode.innerText = beatI;
        timeValueDomNode.innerText = playTime.toFixed(2);

        tellHandlers("onBeat", beatI);
        console.log("beatI", beatI, playTime.toFixed(2));
      }

      let scheduleBeatI = lastScheduledBeatI;
      for (;;) {
        const beatPart = beatReal - beatI;
        const scheduleTime = (lastScheduledTime == null)
          ? playTime          + (beatPart && 1 - beatPart) / bps
          : lastScheduledTime +                          1 / bps;
        if (scheduleTime > playTime + lookaheadDuration)  break;
        lastScheduledTime = scheduleTime;
        lastScheduledBeatI = ++scheduleBeatI;

        tellHandlers("scheduleBeat", scheduleBeatI, startTime + scheduleTime)  // returns an array of arrays of AudioScheduledSourceNode|falsey
          .forEach(ax => ax && ax.forEach( x => {
            if (!x)  return;
            scheduledNodeSet.add(x);
            x.onended = () =>   // on stop/end by _any_ means
              scheduledNodeSet.delete(x);
          }))
      }

      playing ? audioCtx.resume() : audioCtx.suspend();   // seems OK to call this every time

      beatReal += (now - lastScheduleCallTime) * bps;
      lastScheduleCallTime = now;
      // console.log("beatReal",beatReal);
    }

    const resetLookaheadSchedule = () => {
      // Stop only nodes that haven't started playing.
      console.log("** resetLookaheadSchedule", audioCtx.currentTime, scheduledNodeSet.size, beatReal)
      scheduledNodeSet.forEach( x => {
        let stopped;
        if (x.$startTime >= audioCtx.currentTime) {   // == if reset to start time while paused
          stopped = true;
          x.stop();  // resulting onended callback will remove from scheduledNodeSet
        }
        console.log(x.$startTime, stopped?"stop":"spare", +(x.$startTime - audioCtx.currentTime).toFixed(4), x);
      } );

      // next incrementLookaheadSchedule will rebuild the schedule starting at playTime/beatReal
      const beatI = Math.floor(beatReal);
      lastScheduledBeatI = beatI - ((beatI == beatReal) && 1);  // schedule _next_ beat, unless exactly at start of _this_ one
      lastScheduledTime = null;
    }

    const restart = () => {
      console.log("restart");
      scheduledNodeSet.forEach( x => {
        console.log("stop", x);
        x.stop();  // stop even already-playing notes
      } );
      startTime = audioCtx.currentTime;
      beatReal = 0;
      lastBeatI = -1;
      lastScheduledBeatI = -1;
      lastScheduledTime = null;
      audioCtx.suspend();  // but still perhaps playing==true: if so, will resume in incrementLookaheadSchedule; ensures we schedule first beat!
    }
    restart();

    const scheduleForever = () => {
      incrementLookaheadSchedule();
      window.requestAnimationFrame(scheduleForever)
    }
    window.requestAnimationFrame(scheduleForever)  // https://www.html5rocks.com/en/tutorials/audio/scheduling/


    audioCtx.suspend();
    document.querySelector('#play-pause-button').addEventListener('click', () => {
      playing = !playing
      document.querySelector('#app-root').classList.toggle('playing',playing)
      console.log("playing",playing);
    });
    document.querySelector('#restart-button').addEventListener('click', restart);


    // TODO: refactor: extract a component or whatever
    const bpmControl = document.querySelector('#bpm-control');
    const bpmInput = bpmControl.querySelector('input');
    const bpmValue = bpmControl.querySelector('.value');
    const adjustBps = () => {
      console.log("bpm", +bpmInput.value);
      bps = +bpmInput.value / 60;
      bpmValue.innerText = +bpmInput.value;
      resetLookaheadSchedule();
    }
    adjustBps();
    bpmInput.addEventListener('input', adjustBps);


    return {
      register: handler => handlers.add(handler),
      reset: resetLookaheadSchedule,
    }
  }

  const makeMaster = () => {
    const master = audioCtx.createGain();
    master.gain.value = 0.2;
    master.connect(audioCtx.destination);

    // TODO: refactor: extract a component or whatever
    const gainControl = document.querySelector('#gain-control');
    const gainInput = gainControl.querySelector('input');
    const gainValue = gainControl.querySelector('.value');
    const adjustGain = () => {
      console.log("gain", +gainInput.value);
      master.gain.linearRampToValueAtTime(+gainInput.value, audioCtx.currentTime + 0.01);
      gainValue.innerText = (+gainInput.value).toFixed(2);
    }
    adjustGain();
    gainInput.addEventListener('input', adjustGain);

    return master;
  }

  const attachBeatGrid = (scheduler, master) => {  // TODO: inject drumNotes as param (and then TODO from model)... behaviorally: extracting scheduleOscillator
    const RUN = () => {
      renderBeatGrid();
      registerWithScheduler();
    }

    const stepCount = 8;
    const drumNotes = [ 69-12, 69-7, 69 ];  // 69 == MIDI A4; 12 == octave note width;   TODO: inject behaviorally: extracting scheduleOscillator
    const grid = [];

    const renderBeatGrid = () => {
      drumNotes.forEach( (drumNote, drumI) => {
        const drum = [];
        grid.push(drum);

        const drumRow = document.createElement('div');
        document.querySelector('#beat-grid').appendChild( drumRow );
        for (let stepI = 0; stepI < stepCount; stepI++) {
          drum.push(false);
          const button = document.createElement('button');
          button.addEventListener('click', () => {
            drum[stepI] = !drum[stepI];
            button.classList.toggle('on', drum[stepI]);
            scheduler.reset();
          });
          drumRow.appendChild(button);
        }
      })
    }

    registerWithScheduler = () => {
      // TODO: removal
      // TODO: or maybe: scheduler.addEventListener("schedule-beat", ()   ... BUT how to return values?
      scheduler.register({

        scheduleBeat: (scheduleBeatI, startTime) => {
          const stepI = scheduleBeatI % stepCount;

          const scheduleOscillator = midiNote => {  // TODO: Inject this a drum
            const duration = 1.0;
            const oscillator = audioCtx.createOscillator();
            oscillator.$startTime = startTime;  // dirty?  for later cancellation
            // oscillator.type = 'triangle';
            oscillator.frequency.value = freqForMidiNoteNumber(midiNote);
            oscillator.start(startTime + 0.0);
            oscillator.stop (startTime + duration*2);

            const envelope = audioCtx.createGain();
            envelope.gain.setValueAtTime               (0.0, startTime + 0);                 // initial
            envelope.gain.linearRampToValueAtTime    (0.001, startTime + 0.00000001);        // exponentialRampToValueAtTime clicks if started from 0
            envelope.gain.exponentialRampToValueAtTime (1.0, startTime + duration * 0.015);  // Attack
            envelope.gain.exponentialRampToValueAtTime (0.3, startTime + duration * 0.4);    // Decay
            envelope.gain.setValueAtTime               (0.3, startTime + duration * 0.8);    // Sustain
            envelope.gain.linearRampToValueAtTime      (0.0, startTime + duration * 2.0);    // Release

            oscillator.connect(envelope);
            envelope.connect(master);

            // console.log("schedule start", startTime, midiNote, audioCtx.currentTime, );
            return oscillator;  // an AudioScheduledSourceNode, for lookahead management by scheduler
          }

          return drumNotes.map( (drumNote, drumI) =>
            grid[drumI][stepI]  &&  scheduleOscillator(drumNote, startTime)
          );
        },

        onBeat: beatI => {
          if (!(beatI%8))  console.log("-- beatI LOOP", beatI%8, beatI);

          // TODO: keep beat buttons indexed by beat and use those, rather than using selectors? messy?
          document.querySelectorAll('#beat-grid button.current')
            .forEach(x => x.classList.remove('current'));
          document.querySelectorAll(`#beat-grid button:nth-child(${ 1 + beatI % stepCount })`)
            .forEach(x => x.classList.add('current'));
        },

      });
    }

    RUN();
  }


  // "Globals"
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();  // TODO: by browser policy, must (I THINK!) be created in a click handler or all audio is muted (ok for now on desktop Chrome, but to change in next Chrome release)
  const freqForMidiNoteNumber = n => Math.pow(2, (n-69)/12) * 440

  RUN();

</script>

</html>
